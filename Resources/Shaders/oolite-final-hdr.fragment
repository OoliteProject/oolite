out vec4 FragColor;

in vec2 TexCoords;

uniform sampler2D	scene;
uniform sampler2D	bloomBlur;
uniform bool		bloom;
uniform int			uPostFX;
uniform float		uTime;
uniform vec2		uResolution;
uniform float		uMaxBrightness;
uniform float		uPaperWhiteBrightness;
uniform float		uSaturation;


#define SMPTE_ST2084MAXNITS	10000.0
#define MAXCLLNITS			1000.0
#define HDR_HEATMAP			0
#define SATURATION_ADJUSTMENT	0.825 //adjustment factor to better approach SDR saturation
#define GAMUT_EXPANSION_AMOUNT	0.2 //0.0f .. 1.0f - best results if this is kept low



vec3 reinhardHDR(vec3 x)
{
	x.r /= MAXCLLNITS * 0.0125;
	x.g /= MAXCLLNITS * 0.0125;
	x.b /= MAXCLLNITS * 0.0125;
	
	x = x / (x + vec3(1.0));
	
	x.r *= uMaxBrightness * 0.0125;
	x.g *= uMaxBrightness * 0.0125;
	x.b *= uMaxBrightness * 0.0125;
	
	return x;
}


vec3 ACESFilmRec2020( vec3 x, float a, float b, float c, float d, float e )
{
	x *= 0.6;
	return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );
}


vec3 ACESFilmRec2020OrReinhardHDR(vec3 x)
{
	float use400 = 1.0 - abs(sign(uMaxBrightness - 400.0));
	float use500 = 1.0 - abs(sign(uMaxBrightness - 500.0));
	float use600 = 1.0 - abs(sign(uMaxBrightness - 600.0));
	float use800 = 1.0 - abs(sign(uMaxBrightness - 800.0));
	float use1000 = 1.0 - abs(sign(uMaxBrightness - 1000.0));
	float useACES = use400 + use500 + use600 + use800 + use1000;
	// only one column of coefficients will be used, based on current max brightness
	float a = 15.8f	* use1000	+	15.8f * use800	+	27.7f * use600	+	27.7f * use500	+	19.2f * use400;
	float b = 2.12f	* use1000	+	2.12f * use800	+	1.22f * use600	+	1.22f * use500	+	1.22f * use400;
	float c = 1.20f	* use1000	+	1.58f * use800	+	3.70f * use600	+	4.80f * use500	+	4.80f * use400;
	float d = 5.92f	* use1000	+	5.92f * use800	+	9.80f * use600	+	9.80f * use500	+	15.0f * use400;
	float e = 1.90f	* use1000	+	1.90f *	use800	+	3.90f * use600	+	3.90f * use500	+	3.90f * use400;
	return useACES == 1.0 ? ACESFilmRec2020(x, a, b, c, d, e) : reinhardHDR(x);
}


vec3 ACESFilmRec2020Alt( vec3 x )
{
	//x *= 0.6;
	const float ACESLuminancePercentage = 100.0;
	float a = 0.98;
	float b = 0.3;
	float c = 0.22;
	float d = 0.0;
	float e = 0.025;
	x = x * ACESLuminancePercentage * 0.006f;
	return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );
}


vec3 ApplySMPTE_ST2084Curve(vec3 L)
{
    float m1 = 2610.0 / 4096.0 / 4.0;
    float m2 = 2523.0 / 4096.0 * 128.0;
    float c1 = 3424.0 / 4096.0;
    float c2 = 2413.0 / 4096.0 * 32.0;
    float c3 = 2392.0 / 4096.0 * 32.0;
    vec3 Lp = pow(L, vec3(m1));
    return pow((c1 + c2 * Lp) / (1.0 + c3 * Lp), vec3(m2));
}


vec3 RemoveSMPTE_ST2084Curve(vec3 N)
{
    float m1 = 2610.0 / 4096.0 / 4.0;
    float m2 = 2523.0 / 4096.0 * 128.0;
    float c1 = 3424.0 / 4096.0;
    float c2 = 2413.0 / 4096.0 * 32.0;
    float c3 = 2392.0 / 4096.0 * 32.0;
    vec3 Np = pow(N, vec3(1.0 / m2));
    return pow(max(Np - c1, 0) / (c2 - c3 * Np), vec3(1.0 / m1));
}


vec3 Rec709toRec2020(vec3 rgb709)
{
	const mat3 convMat = mat3(
		0.627402, 0.069095, 0.016394,
		0.329292, 0.919544, 0.088028,
		0.043306, 0.011360, 0.895578
	);
	return convMat * rgb709;
}


vec3 Rec2020toRec709(vec3 rgb2020)
{
	const mat3 convMat = mat3(
		1.660496, -0.124547, -0.018154,
		-0.587656, 1.132895, -0.100597,
		-0.072840, -0.008348, 1.118751
	);
	return convMat * rgb2020;
}


mat3 saturationMatrix( float saturation )
{
	vec3 luminance = vec3(0.2126, 0.7152, 0.0722);
    float oneMinusSat = 1.0 - saturation;
	
    vec3 red = vec3( luminance.x * oneMinusSat );
    red.r += saturation;
    
    vec3 green = vec3( luminance.y * oneMinusSat );
    green.g += saturation;
    
    vec3 blue = vec3( luminance.z * oneMinusSat );
    blue.b += saturation;
		
	return mat3( 
        red,     
        green,   
        blue);
}


// ==========================================================================================
// grayscale
// ==========================================================================================
vec3 grayscale(vec3 col)
{
	vec3 luma = vec3(0.2126, 0.7152, 0.0722);
	col = vec3(dot(col, luma));
	
	return col;
}
// ------------------------------------------------------------------------------------------

// ==========================================================================================
// cloak vision - original code by Nikos Papadopoulos, https://www.shadertoy.com/view/Xsl3zf
// ==========================================================================================
float hash(float n)
{
	return fract(sin(n)*43758.5453123);
}

vec3 cloakVision(vec3 c)
{
	vec2 p = TexCoords;
	vec2 u = p * 2. - 1.;
	vec2 n = u;
	float time = uTime;
    
    
	// flicker, grain, vignette, fade in
	c += sin(hash(uTime)) * 0.01;
	c += hash((hash(n.x) + n.y) * uTime) * 0.25;
	c *= smoothstep(length(n * n * n * vec2(0.075, 0.4)), 1.0, 0.4);
    c *= smoothstep(0.001, 3.5, uTime) * 1.5;
	 
	c = grayscale(c) * vec3(0.2, 0.4, 1.5 - hash(uTime) * 0.3);
	
	return c;
}
// ------------------------------------------------------------------------------------------

// ==========================================================================================
// color blindness correction - see https://terra-howard.com/thesis/
// ==========================================================================================
const mat3 RGBtoOpponentMat = mat3(0.2814, -0.0971, -0.0930, 0.6938, 0.1458,-0.2529, 0.0638, -0.0250, 0.4665);
const mat3 OpponentToRGBMat = mat3(1.1677, 0.9014, 0.7214, -6.4315, 2.5970, 0.1257, -0.5044, 0.0159, 2.0517);

//const int NONE = 0;
const int PROTANOPIA = 1;
const int DEUTERANOPIA = 2;
const int TRITANOPIA = 3;

int blindnessType = uPostFX;

void blindnessFilter( out vec3 myoutput, in vec3 myinput )
{
	if (blindnessType == PROTANOPIA) {
			vec3 opponentColor = RGBtoOpponentMat * myinput;
			opponentColor.x -= opponentColor.y * 1.5; // reds (y <= 0) become lighter, greens (y >= 0) become darker
			vec3 rgbColor = OpponentToRGBMat * opponentColor;
			myoutput = max(vec3(0.0),rgbColor);
	} else if (blindnessType == DEUTERANOPIA) {
			vec3 opponentColor = RGBtoOpponentMat * myinput;
			opponentColor.x -= opponentColor.y * 1.5; // reds (y <= 0) become lighter, greens (y >= 0) become darker
			vec3 rgbColor = OpponentToRGBMat * opponentColor;
			myoutput = max(vec3(0.0),rgbColor);
	} else if (blindnessType == TRITANOPIA) {
			vec3 opponentColor = RGBtoOpponentMat * myinput;
			opponentColor.x -= ((3.0 * opponentColor.z) - opponentColor.y) * 0.25;
			vec3 rgbColor = OpponentToRGBMat * opponentColor;
			myoutput = max(vec3(0.0),rgbColor);
    } else {
			myoutput = myinput;
	}	
}

void blindnessVision( out vec3 myoutput, in vec3 myinput )
{
	vec4 blindVisionR;
	vec4 blindVisionG;
	vec4 blindVisionB;
	if (blindnessType == PROTANOPIA) {
			blindVisionR = vec4( 0.20,  0.99, -0.19, 0.0);
			blindVisionG = vec4( 0.16,  0.79,  0.04, 0.0);
			blindVisionB = vec4( 0.01, -0.01,  1.00, 0.0);
	} else if (blindnessType == DEUTERANOPIA) {
			blindVisionR = vec4( 0.43,  0.72, -0.15, 0.0 );
			blindVisionG = vec4( 0.34,  0.57,  0.09, 0.0 );
			blindVisionB = vec4(-0.02,  0.03,  1.00, 0.0 );		
	} else if (blindnessType == TRITANOPIA) {
			blindVisionR = vec4( 0.97,  0.11, -0.08, 0.0 );
			blindVisionG = vec4( 0.02,  0.82,  0.16, 0.0 );
			blindVisionB = vec4(-0.06,  0.88,  0.18, 0.0 );
	} else {
        	blindVisionR = vec4(1.0,  0.0,  0.0, 0.0 );
        	blindVisionG = vec4(0.0,  1.0,  0.0, 0.0 );
        	blindVisionB = vec4(0.0,  0.0,  1.0, 0.0 );			
	}
	myoutput = max(vec3(0.0), vec3(dot(myinput, blindVisionR.rgb), dot(myinput, blindVisionG.rgb), dot(myinput, blindVisionB.rgb)));	
}

vec3 colorBlindness(vec3 inColor)
{
	vec3 texColor = inColor;
	vec3 tmp;
	vec3 colorBlindColor = inColor;
    blindnessFilter(tmp, texColor);    
    blindnessVision(colorBlindColor, tmp);
	//blindnessVision(colorBlindColor, texColor);
	
	return colorBlindColor;
}
// ------------------------------------------------------------------------------------------


// ==========================================================================================
// old movie - based on https://www.shadertoy.com/view/Xdl3D8
// ==========================================================================================
#define BLACK_AND_WHITE
#define LINES_AND_FLICKER
#define BLOTCHES
#define GRAIN
//#define ROLLING_FILM

#define FREQUENCY 15.0
#define sepia mat3(0.393, 0.769, 0.189, 0.349, 0.686, 0.168, 0.272, 0.534, 0.131)

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
}

float rand(float c){
	return rand(vec2(c,1.0));
}

float randomLine(float seed, vec2 uv)
{
	float b = 0.01 * rand(seed);
	float a = rand(seed+1.0);
	float c = rand(seed+2.0) - 0.5;
	float mu = rand(seed+3.0);
	
	float l = 1.0;
	
	if ( mu > 0.2)
		l = pow(  abs(a * uv.x + b * uv.y + c ), 1.0/8.0 );
	else
		l = 2.0 - pow( abs(a * uv.x + b * uv.y + c), 1.0/8.0 );				
	
	return mix(0.5, 1.0, l);
}

// Generate some blotches.
float randomBlotch(float seed, vec2 uv)
{
	float x = rand(seed);
	float y = rand(seed+1.0);
	float s = 0.01 * rand(seed+2.0);
	
	vec2 p = vec2(x,y) - uv;
	p.x *= uResolution.x / uResolution.y;
	float a = atan(p.y,p.x);
	float v = 1.0;
	float ss = s*s * (sin(6.2831*a*x)*0.1 + 1.0);
	
	if ( dot(p,p) < ss ) v = 0.2;
	else
		v = pow(dot(p,p) - ss, 1.0/16.0);
	
	return mix(0.3 + 0.2 * (1.0 - (s / 0.02)), 1.0, v);
}

vec3 oldMovie(sampler2D inImage, vec2 fragCoord) 
{
    vec3 fragColor = vec3(0.0);
	vec2 uv = fragCoord;		
	// Set frequency of global effect to 15 variations per second
	float t = float(int(uTime * FREQUENCY));
	
	// Get some image movement
	vec2 suv = uv + 0.002 * vec2( rand(t), rand(t + 23.0));
	
	// Get the image
	vec3 image = texture( inImage, vec2(suv.x, suv.y) ).xyz;
	
	#ifdef BLACK_AND_WHITE
	// Convert it to B/W
	//float luma = dot( vec3(0.2126, 0.7152, 0.0722), image );
	//vec3 oldImage = luma * vec3(0.7, 0.7, 0.7);
	vec3 oldImage = image * sepia;
	#else
	vec3 oldImage = image;
	#endif
	
	#ifdef ROLLING_FILM
	// rolling film effect
	vec2 nos_pos = fragCoord - 0.5 + vec2(min(fract(uTime) - 0.02, 0.0), 0.0);
    vec2 abs_n_p = vec2(abs(nos_pos));
	if(abs_n_p.x > 0.40)
    {
        if(abs_n_p.x > 0.42 && abs_n_p.x < 0.48)
        	oldImage = vec3(0.7) * step(mod(10.0 * (nos_pos.y + fract(uTime)), 1.0), 0.8);
    	else
            oldImage = vec3(0.0);
    }
	#endif
	
	// Create a time-varying vignetting effect
	float vI = 16.0 * (uv.x * (1.0-uv.x) * uv.y * (1.0-uv.y));
	vI *= mix( 0.7, 1.0, rand(t + 0.5));
	
	// Add additive flicker
	vI += 1.0 + 0.4 * rand(t+8.);
	
	// Add a fixed vignetting (independent of the flicker)
	vI *= pow(16.0 * uv.x * (1.0-uv.x) * uv.y * (1.0-uv.y), 0.4);
	
	// Add some random lines and some multiplicative flicker
	#ifdef LINES_AND_FLICKER
	int l = int(8.0 * rand(t+7.0));
	
	if ( 0 < l ) vI *= randomLine( t+6.0+17.* float(0), uv);
	if ( 1 < l ) vI *= randomLine( t+6.0+17.* float(1), uv);
	if ( 2 < l ) vI *= randomLine( t+6.0+17.* float(2), uv);		
	if ( 3 < l ) vI *= randomLine( t+6.0+17.* float(3), uv);
	if ( 4 < l ) vI *= randomLine( t+6.0+17.* float(4), uv);
	if ( 5 < l ) vI *= randomLine( t+6.0+17.* float(5), uv);
	if ( 6 < l ) vI *= randomLine( t+6.0+17.* float(6), uv);
	if ( 7 < l ) vI *= randomLine( t+6.0+17.* float(7), uv);
	
	#endif
	
	// Add some random blotches.
	#ifdef BLOTCHES
	int s = int( max(8.0 * rand(t+18.0) -2.0, 0.0 ));
    
	if ( 0 < s ) vI *= randomBlotch( t+6.0+19.* float(0), uv);
	if ( 1 < s ) vI *= randomBlotch( t+6.0+19.* float(1), uv);
	if ( 2 < s ) vI *= randomBlotch( t+6.0+19.* float(2), uv);
	if ( 3 < s ) vI *= randomBlotch( t+6.0+19.* float(3), uv);
	if ( 4 < s ) vI *= randomBlotch( t+6.0+19.* float(4), uv);
	if ( 5 < s ) vI *= randomBlotch( t+6.0+19.* float(5), uv);
	
	#endif
	
	// Show the image modulated by the defects
    fragColor = oldImage * vI;
	
	// Add some grain
	#ifdef GRAIN
    fragColor *= (1.0+(rand(uv+t*.01)-.2)*.15);		
    #endif
	
	return fragColor;
}
// ------------------------------------------------------------------------------------------

// ==========================================================================================
// gravitational lensing - based on https://www.shadertoy.com/view/llyyRm
// ==========================================================================================
#define S_RADIUS 0.1
#define HALO_BRIGHTNESS .25

#define PI 3.14159265358979

vec3 hsv2rgb(vec3 c) {
  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 gravLens( sampler2D inImage, vec2 fragCoord )
{
	vec3 fragColor = vec3(0.0);
	// Normalized pixel coordinates (from 0 to 1)
	vec2 uv = fragCoord;
	float aspectRatio = uResolution.x/uResolution.y;
	
	vec2 blackHolePos = vec2(
		sin(uTime) + aspectRatio,
		(cos(uTime * 1.22) + sin(uTime * .57))
		) * .2 + .5;
	vec2 coord = uv - blackHolePos;
    
	//really cheap gravitational lensing approximation follows
	float len = 1. + (length(coord) - S_RADIUS) / S_RADIUS;
    
	if (len < S_RADIUS)
	{
		fragColor = vec3(0.0);
		return fragColor;
	}
	
	vec2 k = (coord / (len * len));
	vec2 sCoord = uv - k;
	
	// compute halo
	float haloBrightness = 0.2;
	haloBrightness = pow(haloBrightness, 4.);
	vec3 hsv = vec3(sCoord.x * .3, .6, haloBrightness);
	vec3 haloColor = hsv2rgb(hsv);
	haloBrightness = (haloColor.r + haloColor.g + haloColor.b) * HALO_BRIGHTNESS;
	haloColor = haloColor * HALO_BRIGHTNESS + vec3(haloBrightness);
	
	fragColor = (texture(inImage, sCoord).rgb + haloColor);
	return fragColor;
}
// ------------------------------------------------------------------------------------------

// ==========================================================================================
// CRT - based on https://www.shadertoy.com/view/Xtccz4
// ==========================================================================================
vec2 crt_coords(vec2 uv, float bend)
{
	uv -= 0.5;
    uv *= 2.;
    uv.x *= 1. + pow(abs(uv.y)/bend, 2.);
    uv.y *= 1. + pow(abs(uv.x)/bend, 2.);
    
    uv /= 2.02;
    return uv + .5;
}

float vignette(vec2 uv, float size, float smoothness, float edgeRounding)
{
 	uv -= .5;
    uv *= size;
    float amount = sqrt(pow(abs(uv.x), edgeRounding) + pow(abs(uv.y), edgeRounding));
    amount = 1. - amount;
    return smoothstep(0., smoothness, amount);
}

float scanline(vec2 uv, float lines, float speed)
{
    return sin(uv.y * lines + uTime * speed);
}

float random(vec2 uv)
{
 	return fract(sin(dot(uv, vec2(15.5151, 42.2561))) * 12341.14122 * sin(uTime * 0.03));   
}

float noise(vec2 uv)
{
 	vec2 i = floor(uv);
    vec2 f = fract(uv);
    
    float a = random(i);
    float b = random(i + vec2(1.,0.));
	float c = random(i + vec2(0., 1.));
    float d = random(i + vec2(1.));
    
    vec2 u = smoothstep(0., 1., f);
    
    return mix(a,b, u.x) + (c - a) * u.y * (1. - u.x) + (d - b) * u.x * u.y; 
                     
}

vec3 CRT(sampler2D inImage, vec2 inCoords)
{
	vec2 uv = inCoords;
	vec2 crt_uv = crt_coords(uv, 8.);
    
    float s1 = scanline(uv, 1500., -10.);
    float s2 = scanline(uv, 10., -3.);
    
    vec3 col = texture(inImage, crt_uv).rgb;
    col.r = texture(inImage, crt_uv + vec2(0., 0.0025)).r;
    col.g = texture(inImage, crt_uv).g;
    col.b = texture(inImage, crt_uv + vec2(0., -0.0025)).b;
    
    col = mix(col, max(vec3(s1 + s2), vec3(0.0)), 0.05);
	col = mix(col, vec3(noise(uv * 500.)), 0.05) * vignette(uv, 1.9, .6, 8.);
	
	return col;
}
// ------------------------------------------------------------------------------------------

// =======================================================================================
// CRTBadSignal - original at https://www.shadertoy.com/view/ltV3z1
// =======================================================================================
vec3 CRTBadSignal(sampler2D inImage, vec2 inCoords)
{
	vec2 uv = inCoords;
	float t = uTime;
	float fx = 0.001 + 25.0 * abs(sin(t) / 10.0) - mod(1.0 + t, 7.0);
	const float s = 50.0; // noise intensity
	float x = (floor(uv.x * 300.0)) + (floor(uv.y * 300.0)) * (t * 0.1);
	vec4 dtv = vec4(mod((mod(x, 2.0) + 1.0) * (mod(x, 0.0) + 0.0), 0.01) - 0.005) * s;
	vec3 col = clamp(vec3(0.1, 0.1, 0.1) + dtv.xyz / fx, vec3(0.0), vec3(0.1));
	
	col.xyz += texture(inImage,uv).xyz;
	
	return col;
}
// ------------------------------------------------------------------------------------------


// =======================================================================================
// FXAA - original at https://www.shadertoy.com/view/MdyyRt
// =======================================================================================
#define FXAA_STRENGTH 10.
vec3 FXAA(sampler2D _Tex, vec2 uv)
{
	vec3 e = vec3(1./uResolution.xy,0.);
	float reducemul = 0.125;// 1. / 8.;
	float reducemin = 0.0078125;// 1. / 128.;
	
	vec4 Or = texture(_Tex,uv);
	vec4 LD = texture(_Tex,uv - e.xy);
	vec4 RD = texture(_Tex,uv + vec2( e.x,-e.y));
	vec4 LT = texture(_Tex,uv + vec2(-e.x, e.y));
	vec4 RT = texture(_Tex,uv + e.xy);
	float Or_Lum = grayscale(Or.rgb).x;
	float LD_Lum = grayscale(LD.rgb).x;
	float RD_Lum = grayscale(RD.rgb).x;
	float LT_Lum = grayscale(LT.rgb).x;
	float RT_Lum = grayscale(RT.rgb).x;
	
	float min_Lum = min(Or_Lum,min(min(LD_Lum,RD_Lum),min(LT_Lum,RT_Lum)));
	float max_Lum = max(Or_Lum,max(max(LD_Lum,RD_Lum),max(LT_Lum,RT_Lum)));
	
	//x direction,-y direction
	vec2 dir = vec2((LT_Lum+RT_Lum)-(LD_Lum+RD_Lum),(LD_Lum+LT_Lum)-(RD_Lum+RT_Lum));
	float dir_reduce = max((LD_Lum+RD_Lum+LT_Lum+RT_Lum)*reducemul*0.25,reducemin);
	float dir_min = 1./(min(abs(dir.x),abs(dir.y))+dir_reduce);
	dir = min(vec2(FXAA_STRENGTH),max(-vec2(FXAA_STRENGTH),dir*dir_min)) * e.xy;
	
	vec4 resultA = 0.5*(texture(_Tex,uv-0.166667*dir)+texture(_Tex,uv+0.166667*dir));
	vec4 resultB = resultA*0.5+0.25*(texture(_Tex,uv-0.5*dir)+texture(_Tex,uv+0.5*dir));
	float B_Lum = grayscale(resultB.rgb).x;
	
	if(B_Lum < min_Lum || B_Lum > max_Lum)
	{
		return resultA.rgb;
	}
	else
	{
		return resultB.rgb;
	}
}
//------------------------------------------------------------------------------------------


vec3 ACESFilm(vec3 color)
{
	// taken from https://www.shadertoy.com/view/XsGfWV This is based on the actual
	// ACES sources and is effectively the glsl translation of Stephen Hill's fit
	// (https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl)
	mat3 m1 = mat3(
        0.59719, 0.07600, 0.02840,
        0.35458, 0.90834, 0.13383,
        0.04823, 0.01566, 0.83777
	);
	mat3 m2 = mat3(
        1.60475, -0.10208, -0.00327,
        -0.53108,  1.10813, -0.07276,
        -0.07367, -0.00605,  1.07602
	);
	// prevents some ACES artifacts, especially bright blues shifting towards purple
	// see https://community.acescentral.com/t/colour-artefacts-or-breakup-using-aces/520/48
	mat3 highlightsFixLMT = mat3(
	0.9404372683, -0.0183068787, 0.0778696104,
	0.0083786969, 0.8286599939, 0.1629613092,
	0.0005471261, -0.0008833746, 1.0003362486
	);
	vec3 v = m1 * color * highlightsFixLMT;    
	vec3 a = v * (v + 0.0245786) - 0.000090537;
	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
	return clamp(m2 * (a / b), 0.0, 1.0);
}


//==========================================================================================
//Gamut expansion - modified from original code, courtesy of the HDR Den Discord server devs
//==========================================================================================
vec3 okLabFromBT709 (vec3 bt709)
{
	const mat3 BT709_2_OKLABLMS = mat3(
		0.4122214708f, 0.5363325363f, 0.0514459929f,
		0.2119034982f, 0.6806995451f, 0.1073969566f,
		0.0883024619f, 0.2817188376f, 0.6299787005f);
	
	const mat3 OKLABLMS_2_OKLAB = mat3(
		0.2104542553f,  0.7936177850f, -0.0040720468f,
		1.9779984951f, -2.4285922050f,  0.4505937099f,
		0.0259040371f,  0.7827717662f, -0.8086757660f);
	
	vec3 lms = bt709 * BT709_2_OKLABLMS;
	lms = sign(lms) * pow(abs(lms), vec3(1.0f / 3.0f));
	
	return lms * OKLABLMS_2_OKLAB;
}


vec3 bt709FromOKLab (vec3 oklab)
{
	const mat3 OKLAB_2_OKLABLMS = mat3(
		1.0f,  0.3963377774f,  0.2158037573f,
		1.0f, -0.1055613458f, -0.0638541728f,
		1.0f, -0.0894841775f, -1.2914855480f);
	
	const mat3 OKLABLMS_2_BT709 = mat3(
		4.0767416621f, -3.3077115913f,  0.2309699292f,
		-1.2684380046f,  2.6097574011f, -0.3413193965f,
		-0.0041960863f, -0.7034186147f,  1.7076147010f);
	
	vec3 lms = oklab * OKLAB_2_OKLABLMS;

	lms = lms * lms * lms;

	return lms * OKLABLMS_2_BT709;
}


vec3 expandGamut(vec3 color, float gamutExpansionAmount)
{
	vec3 colorOKLab = okLabFromBT709(color);
	
	// Extract L, C, h from OKLab
	float L = colorOKLab[0];
	float b = colorOKLab[1];
	float a = colorOKLab[2];
	float C = sqrt(a * a + b * b);
	float h = atan(a, b);
	
	// Calculate the exponential weighting factor based on luminance and chroma
	float chromaWeight = 1.0f - exp(-4.0f * C);
	float luminanceWeight = 1.0f - exp(-4.0f * L * L);
	float weight = chromaWeight * luminanceWeight * gamutExpansionAmount;
	
	// Apply the expansion factor
	C *= (1.0f + weight);
	
	// Convert back to OKLab with adjusted chroma
	a = C * cos(h);
	b = C * sin(h);
	vec3 adjustedOKLab = vec3(L, a, b);
	
	vec3 adjustedColor = bt709FromOKLab(adjustedOKLab);
	vec3 colorBT2020 = Rec709toRec2020(adjustedColor);
	colorBT2020 = max(vec3(0.0), colorBT2020); // Clamp to BT2020
	
	return Rec2020toRec709(colorBT2020);
}
//------------------------------------------------------------------------------------------



void main()
{    
	float exposure = 1.0;
	vec3 hdrColor = texture(scene, TexCoords).rgb;      
	vec3 bloomColor = texture(bloomBlur, TexCoords).rgb;
	
	if(bloom)
	{
		hdrColor += bloomColor;
	}
	
	hdrColor *= exposure;
	
	// post processing effects here
	switch(uPostFX)
	{
		case 1:
		case 2:
		case 3:
			hdrColor = colorBlindness(hdrColor);
			break;
		case 4:
			hdrColor = cloakVision(hdrColor);
			break;
		case 5:
			hdrColor = FXAA(scene, TexCoords);
			bloomColor = FXAA(bloomBlur, TexCoords);
			if(bloom)  hdrColor += bloomColor;
			hdrColor *= exposure;
			break;
		case 6:
			hdrColor = oldMovie(scene, TexCoords);
			bloomColor = oldMovie(bloomBlur, TexCoords);
			if(bloom)  hdrColor += bloomColor;
			hdrColor *= exposure;
			break;
		case 7:
			hdrColor = CRT(scene, TexCoords);
			bloomColor = CRT(bloomBlur, TexCoords);
			if(bloom)  hdrColor += bloomColor;
			hdrColor *= exposure;
			break;
		case 8:
			hdrColor = CRTBadSignal(scene, TexCoords);
			bloomColor = CRT(bloomBlur, TexCoords); // yes CRT, not a typo
			if(bloom)  hdrColor += bloomColor;
			hdrColor *= exposure;
			break;
		case 9:
			hdrColor = gravLens(scene, TexCoords);
			bloomColor = gravLens(bloomBlur, TexCoords);
			if(bloom)  hdrColor += bloomColor;
			hdrColor *= exposure;
			break;
		default:
			break;
	}
	
	// we desaturate colors as they become brighter
	vec3 luma = grayscale(hdrColor);
	float t = luma.r;
	t = t * t / (12.0 + t);
	
	// apply saturation
	hdrColor = max(saturationMatrix(uSaturation * SATURATION_ADJUSTMENT) * hdrColor, vec3(0.0));
	
	// mastering to 1000 nits max luminance
	hdrColor = min(hdrColor, vec3(MAXCLLNITS * 0.0125));
	
	// tone mapping - choose one of the below
	// 1. no tone mapping (mainly for testing purposes)
	// vec3 result = hdrColor;
	// 2. Reinhard HDR (good for any value of uMaxBrightness, rather than selected values)
	// vec3 result = reinhardHDR(mix(hdrColor, luma, clamp(t * 80 / uMaxBrightness, 0.0, 1.0)) * uPaperWhiteBrightness * 0.0125);
	// 3. ACES for the max luminances for which we have sigmoid parameters, Reinhard for everything else
	// at 1000 nits max brighness and 80 nits paper white we get the originally intended tone mapping result
	vec3 result = ACESFilmRec2020OrReinhardHDR(mix(hdrColor, luma, clamp(t * 80 / uMaxBrightness, 0.0, 1.0)) * uPaperWhiteBrightness * 0.0125);

	// gamut expansion here
	result = expandGamut(result, GAMUT_EXPANSION_AMOUNT);
	
#if HDR_HEATMAP
	{
		// This code is based on the luminance heatmap effect from https://github.com/13thsymphony/HDRImageViewer
		// Define constants: 9 "stops" for a piecewise linear gradient in scRGB space.
		#define STOP0_NITS 0.00f
		#define STOP1_NITS 3.16f
		#define STOP2_NITS 10.0f
		#define STOP3_NITS 31.6f
		#define STOP4_NITS 100.f
		#define STOP5_NITS 316.f
		#define STOP6_NITS 1000.f
		#define STOP7_NITS 3160.f
		#define STOP8_NITS 10000.f
		
		#define STOP0_COLOR vec3(0.0f, 0.0f, 0.0f) // Black
		#define STOP1_COLOR vec3(0.0f, 0.0f, 1.0f) // Blue
		#define STOP2_COLOR vec3(0.0f, 1.0f, 1.0f) // Cyan
		#define STOP3_COLOR vec3(0.0f, 1.0f, 0.0f) // Green
		#define STOP4_COLOR vec3(1.0f, 1.0f, 0.0f) // Yellow
		#define STOP5_COLOR vec3(1.0f, 0.2f, 0.0f) // Orange
		#define STOP6_COLOR vec3(1.0f, 0.0f, 0.0f) // Red
		#define STOP7_COLOR vec3(1.0f, 0.0f, 1.0f) // Magenta
		#define STOP8_COLOR vec3(1.0f, 1.0f, 1.0f) // White
		
		float nits = grayscale(result).r * 80.0;
		
		// Determine which gradient segment will be used.
		// Only one of useSegmentN will be 1 (true) for a given nits value.
		float useSegment0 = sign(nits - STOP0_NITS) - sign(nits - STOP1_NITS);
		float useSegment1 = sign(nits - STOP1_NITS) - sign(nits - STOP2_NITS);
		float useSegment2 = sign(nits - STOP2_NITS) - sign(nits - STOP3_NITS);
		float useSegment3 = sign(nits - STOP3_NITS) - sign(nits - STOP4_NITS);
		float useSegment4 = sign(nits - STOP4_NITS) - sign(nits - STOP5_NITS);
		float useSegment5 = sign(nits - STOP5_NITS) - sign(nits - STOP6_NITS);
		float useSegment6 = sign(nits - STOP6_NITS) - sign(nits - STOP7_NITS);
		float useSegment7 = sign(nits - STOP7_NITS) - sign(nits - STOP8_NITS);
		
		// Calculate the interpolated color.
		float lerpSegment0 = (nits - STOP0_NITS) / (STOP1_NITS - STOP0_NITS);
		float lerpSegment1 = (nits - STOP1_NITS) / (STOP2_NITS - STOP1_NITS);
		float lerpSegment2 = (nits - STOP2_NITS) / (STOP3_NITS - STOP2_NITS);
		float lerpSegment3 = (nits - STOP3_NITS) / (STOP4_NITS - STOP3_NITS);
		float lerpSegment4 = (nits - STOP4_NITS) / (STOP5_NITS - STOP4_NITS);
		float lerpSegment5 = (nits - STOP5_NITS) / (STOP6_NITS - STOP5_NITS);
		float lerpSegment6 = (nits - STOP6_NITS) / (STOP7_NITS - STOP6_NITS);
		float lerpSegment7 = (nits - STOP7_NITS) / (STOP8_NITS - STOP7_NITS);
		
		//  Only the "active" gradient segment contributes to the output color.
		vec3 output =
			mix(STOP0_COLOR, STOP1_COLOR, lerpSegment0) * useSegment0 +
			mix(STOP1_COLOR, STOP2_COLOR, lerpSegment1) * useSegment1 +
			mix(STOP2_COLOR, STOP3_COLOR, lerpSegment2) * useSegment2 +
			mix(STOP3_COLOR, STOP4_COLOR, lerpSegment3) * useSegment3 +
			mix(STOP4_COLOR, STOP5_COLOR, lerpSegment4) * useSegment4 +
			mix(STOP5_COLOR, STOP6_COLOR, lerpSegment5) * useSegment5 +
			mix(STOP6_COLOR, STOP7_COLOR, lerpSegment6) * useSegment6 +
			mix(STOP7_COLOR, STOP8_COLOR, lerpSegment7) * useSegment7;
			
		result = output;
	}
#endif
	
	// perceptual quantizer
	//result = ApplySMPTE_ST2084Curve(result / SMPTE_ST2084MAXNITS);
	
	FragColor = vec4(result, 1.0);
}
